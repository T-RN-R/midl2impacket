 import "ms-dtyp.idl";
  
 cpp_quote("#ifndef __FIREWALL_H_")
 cpp_quote("#define FW_CURRENT_BINARY_VERSION (FW_VERSION(2,31))")
 cpp_quote("#define FW_CURRENT_SCHEMA_VERSION (FW_VERSION(2,31))")
  
 /***********************************************************************
  *                                                                     *
  *   Firewall Policy Stores structures                                 *
  *                                                                     *
  ***********************************************************************/
  
 typedef enum _tag_FW_STORE_TYPE
 {
     FW_STORE_TYPE_INVALID,
     FW_STORE_TYPE_GP_RSOP,      //read-only
     FW_STORE_TYPE_LOCAL,
     FW_STORE_TYPE_NOT_USED_VALUE_3,   //read-only
     FW_STORE_TYPE_NOT_USED_VALUE_4,
     FW_STORE_TYPE_DYNAMIC,
     FW_STORE_TYPE_GPO,
     FW_STORE_TYPE_DEFAULTS,
     FW_STORE_TYPE_NOT_USED_VALUE_8,
     FW_STORE_TYPE_NOT_USED_VALUE_9,
     FW_STORE_TYPE_NOT_USED_VALUE_10,
     FW_STORE_TYPE_NOT_USED_VALUE_11,
     FW_STORE_TYPE_MAX,
 } FW_STORE_TYPE;
  
 typedef enum _tag_FW_TRANSACTIONAL_STATE
 {
     FW_TRANSACTIONAL_STATE_NONE      = 0,
     FW_TRANSACTIONAL_STATE_NO_FLUSH,
     FW_TRANSACTIONAL_STATE_MAX  
 } FW_TRANSACTIONAL_STATE;
  
 typedef
 [v1_enum]
 enum _tag_FW_PROFILE_TYPE
 {
     FW_PROFILE_TYPE_INVALID  = 0,
     FW_PROFILE_TYPE_DOMAIN   = 0x001,
     FW_PROFILE_TYPE_STANDARD = 0x002,
     FW_PROFILE_TYPE_PRIVATE  = FW_PROFILE_TYPE_STANDARD,
     FW_PROFILE_TYPE_PUBLIC   = 0x004,
     FW_PROFILE_TYPE_ALL      = 0x7FFFFFFF,
     FW_PROFILE_TYPE_CURRENT  = 0x80000000,
     FW_PROFILE_TYPE_NONE     = FW_PROFILE_TYPE_CURRENT + 1
 } FW_PROFILE_TYPE;
  
 typedef enum _tag_FW_POLICY_ACCESS_RIGHT
 {
     FW_POLICY_ACCESS_RIGHT_INVALID,
     FW_POLICY_ACCESS_RIGHT_READ,
     FW_POLICY_ACCESS_RIGHT_READ_WRITE,
     FW_POLICY_ACCESS_RIGHT_MAX
 }FW_POLICY_ACCESS_RIGHT;
  
 typedef enum _tag_FW_POLICY_STORE_FLAGS
 {
     FW_POLICY_STORE_FLAGS_NONE          = 0x0000,
     FW_POLICY_STORE_FLAGS_DELETE_DYNAMIC_RULES_AFTER_CLOSE  = 0x0001,
     FW_POLICY_STORE_FLAGS_OPEN_GP_CACHE = 0x0002,
     FW_POLICY_STORE_FLAGS_USE_GP_CACHE  = 0x0004,    
     FW_POLICY_STORE_FLAGS_SAVE_GP_CACHE  = 0x0008,
     FW_POLICY_STORE_FLAGS_NOT_USED_VALUE_16 = 0x0010,
     FW_POLICY_STORE_FLAGS_MAX           = 0x0020
 }FW_POLICY_STORE_FLAGS;
  
 /********************************************************
  *                                                      *
  *  Firewall Rules structures                           *
  *                                                      *
  ********************************************************/
 typedef struct _tag_FW_IPV4_SUBNET
 {
     DWORD      dwAddress;
     DWORD      dwSubNetMask;
 } FW_IPV4_SUBNET, *PFW_IPV4_SUBNET;
  
 typedef struct _tag_FW_IPV4_SUBNET_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV4_SUBNET    pSubNets;
 } FW_IPV4_SUBNET_LIST, *PFW_IPV4_SUBNET_LIST;
  
  
 typedef struct _tag_FW_IPV6_SUBNET
 {
     BYTE                Address[16];
     [range(0, 128)]
     DWORD               dwNumPrefixBits;
 } FW_IPV6_SUBNET, *PFW_IPV6_SUBNET;
  
 typedef struct _tag_FW_IPV6_SUBNET_LIST
 {
     [range(0, 10000)]
     DWORD               dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV6_SUBNET     pSubNets;
 } FW_IPV6_SUBNET_LIST, *PFW_IPV6_SUBNET_LIST;
  
  
 typedef struct _tag_FW_IPV4_ADDRESS_RANGE
 {
     DWORD      dwBegin;
     DWORD      dwEnd;
 } FW_IPV4_ADDRESS_RANGE, *PFW_IPV4_ADDRESS_RANGE;
  
  
 typedef struct _tag_FW_IPV6_ADDRESS_RANGE
 {
     BYTE     Begin[16];
     BYTE     End[16];
 } FW_IPV6_ADDRESS_RANGE, *PFW_IPV6_ADDRESS_RANGE;
  
 typedef struct _tag_FW_IPV4_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD                       dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV4_ADDRESS_RANGE      pRanges;
 } FW_IPV4_RANGE_LIST, *PFW_IPV4_RANGE_LIST;
  
 typedef struct _tag_FW_IPV6_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD                       dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_IPV6_ADDRESS_RANGE      pRanges;
 } FW_IPV6_RANGE_LIST, *PFW_IPV6_RANGE_LIST;
  
  
 typedef struct _tag_FW_PORT_RANGE
 {
     WORD            wBegin;
     WORD            wEnd;
 } FW_PORT_RANGE, *PFW_PORT_RANGE;
  
 typedef struct _tag_FW_PORT_RANGE_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_PORT_RANGE     pPorts;
 } FW_PORT_RANGE_LIST, *PFW_PORT_RANGE_LIST;         
  
 typedef enum _tag_FW_PORT_KEYWORD
 {
     FW_PORT_KEYWORD_NONE              = 0x00,
     FW_PORT_KEYWORD_DYNAMIC_RPC_PORTS = 0x01,
     FW_PORT_KEYWORD_RPC_EP            = 0x02,
     FW_PORT_KEYWORD_TEREDO_PORT       = 0x04,
     FW_PORT_KEYWORD_IP_TLS_IN         = 0x08,
     FW_PORT_KEYWORD_IP_TLS_OUT        = 0x10,
     FW_PORT_KEYWORD_DHCP              = 0x20,
     FW_PORT_KEYWORD_PLAYTO_DISCOVERY  = 0x40,
     FW_PORT_KEYWORD_MDNS              = 0x80,
     FW_PORT_KEYWORD_CORTANA_OUT       = 0x100,
     FW_PORT_KEYWORD_PROXIMAL_TCP_CDP  = 0x200,
     FW_PORT_KEYWORD_MAX               = 0x400,
     FW_PORT_KEYWORD_MAX_V2_1          = 0x08,
     FW_PORT_KEYWORD_MAX_V2_10         = 0x20,
     FW_PORT_KEYWORD_MAX_V2_20         = 0x80,
     FW_PORT_KEYWORD_MAX_V2_24         = 0x100,
     FW_PORT_KEYWORD_MAX_V2_25         = 0x200
 }FW_PORT_KEYWORD;
  
 typedef struct _tag_FW_PORTS
 {
     WORD                wPortKeywords;     // Bit-flags from FW_PORT_KEYWORD
     FW_PORT_RANGE_LIST  Ports;
 }FW_PORTS,*PFW_PORTS;
  
 cpp_quote("#define FW_ICMP_CODE_ANY (256)")
 cpp_quote("#define FW_IP_PROTOCOL_ANY (256)")
  
 typedef struct _tag_FW_ICMP_TYPE_CODE
 {
     BYTE                bType;
     [range(0, 256)]
     WORD                wCode;
 } FW_ICMP_TYPE_CODE, *PFW_ICMP_TYPE_CODE;
  
 typedef struct _tag_FW_ICMP_TYPE_CODE_LIST 
 {
     [range(0, 10000)]
     DWORD               dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_ICMP_TYPE_CODE  pEntries;
 } FW_ICMP_TYPE_CODE_LIST, *PFW_ICMP_TYPE_CODE_LIST;
  
 typedef struct _tag_FW_INTERFACE_LUIDS
 {
     [range(0, 10000)]
     DWORD       dwNumLUIDs;
     [size_is(dwNumLUIDs)]
     GUID*       pLUIDs;
 } FW_INTERFACE_LUIDS, *PFW_INTERFACE_LUIDS;
  
  
 typedef enum _tag_FW_DIRECTION
 {
     FW_DIR_INVALID = 0,
     FW_DIR_IN,
     FW_DIR_OUT,
     FW_DIR_MAX
 } FW_DIRECTION;
  
 // Interface Types bitmap.
 typedef enum _tag_FW_INTERFACE_TYPE
 {
     FW_INTERFACE_TYPE_ALL            = 0x0000,
     FW_INTERFACE_TYPE_LAN            = 0x0001,
     FW_INTERFACE_TYPE_WIRELESS       = 0x0002,
     FW_INTERFACE_TYPE_REMOTE_ACCESS  = 0x0004,
     FW_INTERFACE_TYPE_MOBILE_BBAND   = 0x0008,
     FW_INTERFACE_TYPE_MAX            = 0x0010,
     FW_INTERFACE_TYPE_MAX_V2_23      = 0x0008,
 } FW_INTERFACE_TYPE;
  
  
 typedef enum _tag_FW_ADDRESS_KEYWORD
 {
     FW_ADDRESS_KEYWORD_NONE            = 0x0000,
     FW_ADDRESS_KEYWORD_LOCAL_SUBNET    = 0x0001,
     FW_ADDRESS_KEYWORD_DNS             = 0x0002,
     FW_ADDRESS_KEYWORD_DHCP            = 0x0004,
     FW_ADDRESS_KEYWORD_WINS            = 0x0008,
     FW_ADDRESS_KEYWORD_DEFAULT_GATEWAY = 0x0010,
     FW_ADDRESS_KEYWORD_INTRANET        = 0x0020,
     FW_ADDRESS_KEYWORD_INTERNET        = 0x0040,
     FW_ADDRESS_KEYWORD_PLAYTO_RENDERERS= 0x0080,
     FW_ADDRESS_KEYWORD_REMOTE_INTRANET = 0x0100,
     FW_ADDRESS_KEYWORD_CAPTIVE_PORTAL  = 0x0200,
     FW_ADDRESS_KEYWORD_MAX             = 0x0400,
     FW_ADDRESS_KEYWORD_MAX_V2_10       = 0x0020,
     FW_ADDRESS_KEYWORD_MAX_V2_29       = 0x0200,
 }FW_ADDRESS_KEYWORD;
  
  
 typedef struct _tag_FW_ADDRESSES
 {
     DWORD                dwV4AddressKeywords; // Bit flags from FW_ADDRESS_KEYWORD
     DWORD                dwV6AddressKeywords; // Bit flags from FW_ADDRESS_KEYWORD
  
     FW_IPV4_SUBNET_LIST  V4SubNets;
     FW_IPV4_RANGE_LIST   V4Ranges;
     FW_IPV6_SUBNET_LIST  V6SubNets;
     FW_IPV6_RANGE_LIST   V6Ranges;
  
 }FW_ADDRESSES, *PFW_ADDRESSES;
  
  
 typedef enum _tag_FW_TRUST_TUPLE_KEYWORD
 {
     FW_TRUST_TUPLE_KEYWORD_NONE                = 0x0000,
     FW_TRUST_TUPLE_KEYWORD_PROXIMITY           = 0x0001,
     FW_TRUST_TUPLE_KEYWORD_PROXIMITY_SHARING   = 0x0002,
     FW_TRUST_TUPLE_KEYWORD_WFD_PRINT           = 0x0004,
     FW_TRUST_TUPLE_KEYWORD_WFD_DISPLAY         = 0x0008,
     FW_TRUST_TUPLE_KEYWORD_WFD_DEVICES         = 0x0010,
     FW_TRUST_TUPLE_KEYWORD_WFD_KM_DRIVER       = 0x0020,
     FW_TRUST_TUPLE_KEYWORD_UPNP                = 0x0040,
     FW_TRUST_TUPLE_KEYWORD_WFD_CDP             = 0x0080,
     FW_TRUST_TUPLE_KEYWORD_MAX                 = 0x0100,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_20           = 0x0004,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_26           = 0x0020,
     FW_TRUST_TUPLE_KEYWORD_MAX_V2_27           = 0x0080
 }FW_TRUST_TUPLE_KEYWORD;
  
  
 typedef
 [v1_enum]
 enum _tag_FW_RULE_STATUS
 {
     FW_RULE_STATUS_OK = 0x00010000,
         // The rule was parsed successfully from the store.
  
     FW_RULE_STATUS_PARTIALLY_IGNORED = 0x00020000,
         // The rule is from a later version of the service. Some fields
         // were not understood and have been ignored. This may cause the
         // rule to be less restrictive than on the version where it was
         // created. To mitigate any risk from this fallback behavior,
         // ensure that the original rule is as specific as possible. To
         // avoid this fallback behavior, create version-specific GPO's, or
         // apply a Platform condition to the rule.
  
     FW_RULE_STATUS_IGNORED = 0x00040000,
         // The rule is from a newer schema version than the service, and
         // the unknown fields could not be ignored.  The whole rule was
         // ignored.
  
     FW_RULE_STATUS_PARSING_ERROR = 0x00080000,
         // The service was unable to parse the rule.
  
     FW_RULE_STATUS_PARSING_ERROR_NAME = 0x00080001,
         // The name contains invalid characters, or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_DESC = 0x00080002,
         // The description contains invalid characters, or is an invalid
         // length.
  
     FW_RULE_STATUS_PARSING_ERROR_APP = 0x00080003,
         // The application contains invalid characters, or is an invalid
         // length.
  
     FW_RULE_STATUS_PARSING_ERROR_SVC = 0x00080004,
         // The service contains invalid characters, or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_RMA = 0x00080005,
         // The authorized remote machines list contains invalid characters,
         // or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_RUA = 0x00080006,
         // The authorized remote users list contains invalid characters, or
         // is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_EMBD = 0x00080007,
         // The group (sometimes called the embedded context) contains
         // invalid characters, or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_RULE_ID = 0x00080008,
         // The rule ID contains invalid characters, or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_PHASE1_AUTH = 0x00080009,
         // The phase 1 auth set ID contains invalid characters, or is an
         // invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_PHASE2_CRYPTO = 0x0008000A,
         // The quick mode crypto set ID contains invalid characters, or is
         // an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_PHASE2_AUTH = 0x0008000B,
         // The main mode crypto set ID contains invalid characters, or is
         // an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_RESOLVE_APP = 0x0008000C,
         // The application name could not be resolved.
  
     FW_RULE_STATUS_PARSING_ERROR_MAINMODE_ID = 0x0008000D,
         // This error value is not used.
  
     FW_RULE_STATUS_PARSING_ERROR_PHASE1_CRYPTO = 0x0008000E,
         // The phase 2 auth set ID contains invalid characters, or is an
         // invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINTS = 0x0008000F,
         // The remote endpoints are invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINT_FQDN = 0x00080010,
         // The remote endpoint FQDN is invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_KEY_MODULE = 0x00080011,
         // The choice of key modules is invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_LUA = 0x00080012,
         // The local user authorization list contains invalid characters,
         // or is an invalid length.
  
     FW_RULE_STATUS_PARSING_ERROR_FWD_LIFETIME = 0x00080013,
         // The forward path SA lifetime is invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_MACHINE_AUTHZ_SDDL = 0x00080014,
         // The transport rule machine SDDL is not valid.
  
     FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_USER_AUTHZ_SDDL = 0x00080015,
         // The transport rule user SDDL is not valid.
  
     FW_RULE_STATUS_PARSING_ERROR_NETNAMES_STRING = 0x00080016,
         // A string of the network name structure is invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_SECURITY_REALM_ID_STRING = 0x00080017,
         // A string for the security realm Id is invalid.
  
     FW_RULE_STATUS_PARSING_ERROR_FQBN_STRING = 0x00080018,
         // A string for the FQBN is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR = 0x00100000,
         // The rule was parsed successfully, but there was an unknown
         // semantic error when processing the rule.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_RULE_ID = 0x00100010,
         // The Rule ID was not specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTS = 0x00100020,
         // Mismatch in number of ports and ports buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PORT_KEYW = 0x00100021,
         // One of the port keywords is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PORT_RANGE = 0x00100022,
         // An invalid port range was specified, or 0 was used as a port
         // number.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTRANGE_RESTRICTION = 0x00100023,
         // Port ranges are only allowed in connection security rules when
         // the action is Do Not Secure.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_SUBNETS = 0x00100040,
         // Mismatch in number of V4 address subnets and subnets buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_SUBNETS = 0x00100041,
         // Mismatch in number of V6 address subnets and subnets buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_RANGES = 0x00100042,
         // Mismatch in number of V4 address ranges and ranges buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_RANGES = 0x00100043,
         // Mismatch in number of V6 address ranges and ranges buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_RANGE = 0x00100044,
         // The address range is invalid.  The end address is less than the
         // beginning address.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_MASK = 0x00100045,
         // One or more of the subnet masks is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_PREFIX = 0x00100046,
         // One or more of the address prefixes is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYW = 0x00100047,
         // One or more of the address keywords are invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_PROP = 0x00100048,
         // Some of the keywords specified on the local address are only
         // valid on the remote address.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_RADDR_PROP = 0x00100049,
         // Some of the keywords specified on the remote address are only
         // valid on the local address.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6 = 0x0010004A,
         // An unspecified, multicast, broadcast, or loopback IPv6 address
         // was specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_INTF = 0x0010004B,
         // A local address cannot be used in conjunction with an interface
         // or interface type condition.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4 = 0x0010004C,
         // An unspecified, multicast, broadcast, or loopback IPv4 address
         // was specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_ENDPOINT_ADDR = 0x0010004D,
         // Endpoint 'any' cannot be specified for a tunnel-mode rule.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_VER  = 0x0010004E,
         // The target schema version does not support dynamic endpoints.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_MISMATCH_ADDR  = 0x0010004F,
         // When specifying tunnel endpoints in both IPv4 and IPv6, a tunnel
         // endpoint may not be dynamic for one address family and explicit
         // for the other.  (A dynamic tunnel endpoint is one set to "Any".)
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PROFILE = 0x00100050,
         // The profile type is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ICMP = 0x00100060,
         // Mismatch in number of ICMP and ICMP buffer.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ICMP_CODE = 0x00100061,
         // Invalid ICMP code specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_IF_ID = 0x00100070,
         // Number of interfaces and interface buffers do not match.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_IF_TYPE = 0x00100071,
         // The interface type is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ACTION = 0x00100080,
         // The action is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS = 0x00100081,
         // Allow-Bypass action specified, but the rule does not meet
         // allow-bypass criteria (inbound, authenticate/encrypt flags set,
         // remote machine auth list specified) 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DO_NOT_SECURE = 0x00100082,
         // If the action is Do Not Secure, the auth and crypto sets must be
         // null.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ACTION_BLOCK_IS_ENCRYPTED_SECURE = 0x00100083,
         // Block action was specified in conjunction with require security
         // or require encryption.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_INCOMPATIBLE_FLAG_OR_ACTION_WITH_SECURITY_REALM = 0x00100084,
         // Firewall Rules with security realm Id field would require authentication
 // and encryption, and action should be Allow.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DIR = 0x00100090,
         // The direction is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PROT = 0x001000A0,
         // The protocol number is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PROT_PROP = 0x001000A1,
         // The protocol-specific options do not match the protocol that was
         // chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_EDGE_PROP = 0x001000A2,
         // The edge traversal flags are inconsistent.  Defer To App must be
         // set without Edge Traversal, but Defer To User must be set with
         // Edge Traversal.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS_OUTBOUND = 0x001000A3,
         // Allow-Bypass action specified, but the rule does not meet
         // allow-bypass criteria (authenticate/encrypt flags set) 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_USER_INVALID_RULE = 0x001000A4,
         // Defer to user' setting can only be used in a firewall rule where
         // program path and TCP/UDP protocol are specified with no
         // additional conditions.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS = 0x001000B0,
         // Invalid flags specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_AUTH = 0x001000B1,
         // Autogenerate flag is set but Authenticate / Authenticate-encrypt
         // flags are not set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_BLOCK = 0x001000B2,
         // Autogenerate flag is set but the action is block.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_DYN_RPC = 0x001000B3,
         // Autogenerate flag is set along with Dynamic RPC flag.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_ENCRYPT = 0x001000B4,
         // The Authentication and Authentication & Encryption flags cannot
         // be used together.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_VER = 0x001000B5,
         // The target schema version does not support Authentication
         // (Dynamic Encryption).
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE = 0x001000B6,
         // When the Authentication (Dynamic Encryption) flag is set, the
         // Authentication & Encryption flag must be set as well.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP_VER = 0x001000B7,
         // The target schema version does not support Authentication (No
         // Encapsulation).
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP = 0x001000B8,
         // When the Authentication (No Encapsulation) flag is set, the
         // Authentication flag must be set as well.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES_VER = 0x001000B9,
         // The target schema version does not support tunnel authentication
         // modes.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES = 0x001000BA,
         // The target schema version does not support tunnel authentication
         // modes.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_IP_HTTPS_VER = 0x001000BB,
         // The target schema version does not support the IP_HTTPS keyword.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_IP_TLS_VER = 0x001000BB,
         // The target schema version does not support the IP_TLS keyword.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PORTRANGE_VER = 0x001000BC,
         // The target schema version does not support port ranges.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ADDRS_TRAVERSE_DEFER_VER = 0x001000BD,
         // The target schema version does not support dynamic edge
         // traversal.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_OUTBOUND = 0x001000BE,
         // The Authentication (Dynamic Encryption) flag cannot be used when
         // direction is Outbound.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_WITH_OUTBOUND_BYPASS_VER = 0x001000BF,
         // The target schema version does not support outbound Allow-Bypass
         // rules.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_AUTH_LIST = 0x001000C0,
         // Authorization lists can only be used if authentication is
         // required on the rule.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_USER_LIST = 0x001000C1,
         // Remote user authorization can only be applied to inbound rules.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_LIST = 0x001000C2,
         // The authorized local user list may not be used in conjunction
         // with a service SID.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LUA_VER = 0x001000C3,
         // The target schema version does not support the authorized local
         // user list.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER = 0x001000C4,
         // The local user owner field may not be used in conjunction with a
         // service SID.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER_VER = 0x001000C5,
         // The target schema version does not support the local user owner
         // field.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_LUA_CONDITIONAL_VER = 0x001000C6,
         // The target schema version does not support the authorized local
         // user list containing conditional aces (e.g. aces with claims).
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SYSTEMOS_GAMEOS = 0x001000C7,
         // The Sytem OS Only and Game OS Only flags cannot
         // be used together.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_CORTANA_VER = 0x001000C8,
         // The Sytem OS Only and Game OS Only flags cannot
         // be used together.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_REMOTENAME = 0x001000C9,
         // The Sytem OS Only and Game OS Only flags cannot
         // be used together.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ALLOW_PROFILE_CROSSING_VER = 0x001000D0,
         // The target schema version does not support profile crossing.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_LOCAL_ONLY_MAPPED_VER = 0x001000D1,
         // The target schema version does not support local only mapping.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM = 0x001000E0,
         // Number of valid OS Platforms and the list of valid OS Platforms
         // do not match 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP_VER = 0x001000E1,
         // The target schema version does not support the platform operator
         // specified. 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP = 0x001000E2,
         // One of the platform operators is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DTE_NOANY_ADDR = 0x001000F0,
         // The DTM flag requires at least one dynamic endpoint.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_EXEMPT_WITH_GATEWAY = 0x001000F1,
         // A dynamic tunnel-mode exemption rule cannot have tunnel
         // endpoints.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_EXEMPT_VER = 0x001000F2,
         // The target schema version does not support tunnel-mode
         // exemptions.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYWORD_VER = 0x001000F3,
         // The target schema version does not support one or more of the
         // address keywords given.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_KEY_MODULE_VER = 0x001000F4,
         // The target schema version does not support custom key module
         // preferences.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID = 0x00100100,
         // The application package SID is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID_VER = 0x00100101,
         // The target schema version does not support application package
         // SIDs.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INCOMPATIBLE = 0x00100200,
         // Logical endpoints (trust tuples) cannot be combined with
         // specific addresses or ports.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INVALID = 0x00100201,
         // One or more of the logical endpoints (trust tuples) are invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_VER = 0x00100202,
         // The target schema version does not support logical endpoints
         // (trust tuples).
  
     FW_RULE_STATUS_SEMANTIC_ERROR_INTERFACE_TYPES_VER = 0x00100301,
         // The target schema version does not support the specified
         // local interface type
  
     FW_RULE_STATUS_SEMANTIC_ERROR_NETNAMES_VER = 0x00100401,
         // The target schema version does not support the specified
         // local interface type
  
     FW_RULE_STATUS_SEMANTIC_ERROR_SECURITY_REALM_ID_VER = 0x00100402,
         // The target schema version does not support security realm Id
  
     FW_RULE_STATUS_SEMANTIC_ERROR_SYSTEMOS_GAMEOS_VER = 0x00100403,
         // The target schema version does not support specifying System OS or Game OS flag
  
     FW_RULE_STATUS_SEMANTIC_ERROR_DEVMODE_VER = 0x00100404,
         // The target schema version does not support specifying Development mode flag
  
     FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_SERVERNAME_VER = 0x00100405,
         // The target schema version does not support specifying Remote Server Name
         // attributes.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FQBN_VER = 0x00100406,
         // The target schema version does not support specifying fqbn
  
     FW_RULE_STATUS_SEMANTIC_ERROR_COMPARTMENT_ID_VER = 0x00100407,
         // The target schema version does not support specifying compartment Id
  
     FW_RULE_STATUS_SEMANTIC_ERROR_CALLOUT_AND_AUDIT_VER = 0x00100408,
         // The target schema version does not support specifying callout and audit flag
     
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_SET_ID = 0x00100500,
         // The phase 1 auth set ID must be specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_SET_ID = 0x00100510,
         // The quick mode crypto set ID must be specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_SET_ID = 0x00100511,
         // The main mode crypto set ID must be specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_DICTATE_VER = 0x00100512,
         // The target schema version does not support the Key Manager
         // Dictation flag.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_NOTIFY_VER = 0x00100513,
         // The target schema version does not support the Key Manager
         // Notification flag.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_VER = 0x00100514,
         // The target schema version does not support transport rule
         // machine authorization lists.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_VER = 0x00100515,
         // The target schema version does not support transport rule user
         // authorization lists.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_ON_TUNNEL = 0x00100516,
         // Transport machine authorization SDDL specified on tunnel-mode
         // rule.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_ON_TUNNEL = 0x00100517,
         // Transport user authorization SDDL specified on tunnel-mode rule.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PER_RULE_AND_GLOBAL_AUTHZ = 0x00100518,
         // The Apply Global Authorization flag cannot be used when a
         // per-rule authorization list is also specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SECURITY_REALM = 0x00100519,
         // The target schema version does not support security realm flag.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_SET_ID = 0x00101000,
         // The Set ID was not specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_IPSEC_PHASE = 0x00101010,
         // The IPsec phase is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_EMPTY_SUITES = 0x00101020,
         // No suites specified in the set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_METHOD = 0x00101030,
         // One of the phase 1 auth methods is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_AUTH_METHOD = 0x00101031,
         // One of the phase 2 auth methods is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_ANONYMOUS = 0x00101032,
         // Anonymous cannot be the only authentication method.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_DUPLICATE = 0x00101033,
         // The same authentication method cannot be used more than once
         // within a set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_VER = 0x00101034,
         // The target schema version does not support one or more of the
         // authentication methods given.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SUITE_FLAGS = 0x00101040,
         // Invalid auth suite flags specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_HEALTH_CERT = 0x00101041,
         // Machine certificates can only be used in phase 2 auth if they
         // are machine health certificates.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SIGNCERT_VER = 0x00101042,
         // The target schema version does not support the requested
         // certificate signing algorithm.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_INTERMEDIATE_CA_VER = 0x00101043,
         // The target schema version does not support targeting
         // Intermediate CA's.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_SHKEY = 0x00101050,
         // Machine Preshared Key was selected as an authentication type,
         // but no key string was specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_CA_NAME = 0x00101060,
         // The certificate authority name is required, and must be
         // formatted as an X.509 distinguished name.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CERTS = 0x00101061,
         // Machine health certificates and regular certificates cannot both
         // be proposed within the same authentication set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_NON_CONTIGUOUS_CERTS = 0x00101062,
         // When specifying multiple certificate authentication proposals,
         // all the certificate proposals with the same signing method must
         // must be grouped together within the set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CA_TYPE_IN_BLOCK = 0x00101063,
         // This error value is not used.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_USER_AUTH = 0x00101070,
         // Both machine and user auth cannot be proposed within the same
         // authentication set.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER = 0x00101071,
         // The target schema version does not support certificate criteria.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER_MISMATCH = 0x00101072,
         // Certificate criteria version does not match schema version.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_RENEWAL_HASH = 0x00101073,
         // The certificate criteria are invalid.  A thumbprint hash must be
         // specified when FollowRenewal is used.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_HASH = 0x00101074,
         // The certificate criteria are invalid.  The thumbprint hash is
         // invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_EKU = 0x00101075,
         // The certificate criteria are invalid.  One or more of the EKU's
         // are invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME_TYPE = 0x00101076,
         // The certificate criteria are invalid.  The name type is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME = 0x00101077,
         // The certificate criteria are invalid.  The subject name is not
         // valid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_CRITERIA_TYPE = 0x00101078,
         // The certificate criteria are invalid.  The criteria type flags
         // are invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_MISSING_CRITERIA = 0x00101079,
         // The certificate criteria are invalid.  You need to specify at
         // least one set of validation criteria and one set of selection
         // criteria.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PROXY_SERVER = 0x00101080,
         // The Kerberos proxy name must be a fully qualified domain name
         // (FQDN). For example: kerbproxy.contoso.com 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_PROXY_SERVER_VER = 0x00101081,
         // The target schema version does not support kerberos proxy
         // servers.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_NON_DEFAULT_ID = 0x00105000,
         // The main mode crypto set ID should be the global main mode
         // crypto set ID.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_FLAGS = 0x00105001,
         // The phase 1 crypto set flags are invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_MINUTES = 0x00105002,
         // The main mode lifetime, in minutes, is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_SESSIONS = 0x00105003,
         // The main mode lifetime, in sessions, is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCHANGE = 0x00105004,
         // One of the main mode key exchange algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION = 0x00105005,
         // One of the main mode encryption algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH = 0x00105006,
         // One of the main mode hash algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION_VER = 0x00105007,
         // The target schema version does not support one of the main mode
         // encryption algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH_VER = 0x00105008,
         // The target schema version does not support one of the main mode
         // hash algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCH_VER = 0x00105009,
         // The target schema version does not support one of the main mode
         // key exchange algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS = 0x00105020,
         // One of the quick mode key exchange algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PROTOCOL = 0x00105021,
         // One of the quick mode encapsulation types is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION = 0x00105022,
         // One of the quick mode encryption algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH = 0x00105023,
         // One of the quick mode hash algorithms is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_MINUTES = 0x00105024,
         // The quick mode lifetime, in minutes, is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_KBYTES = 0x00105025,
         // The quick mode lifetime, in kilobytes, is invalid.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION_VER = 0x00105026,
         // The target schema version does not support one of the quick mode
         // encryption algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH_VER = 0x00105027,
         // The target schema version does not support one of the quick mode
         // hash algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS_VER = 0x00105028,
         // The target schema version does not support one of the quick mode
         // key exchange algorithms chosen.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH = 0x00105040,
         // Either Encryption or Hash must be specified.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH_COMPAT = 0x00105041,
         // The encryption and hash algorithms specified are incompatible.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_SCHEMA_VERSION = 0x00105050,
         // The target schema version specified is not supported.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_OR_AND_CONDITIONS = 0x00106000,
         // Malformed query: Mismatch in the number of ORed terms and the
         // terms array
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_AND_CONDITIONS = 0x00106001,
         // Malformed query: Mismatch in the number of ANDed conditions and
         // conditions array
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY = 0x00106002,
         // Malformed query: Invalid confition match key
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_MATCH_TYPE = 0x00106003,
         // Malformed query: Invalid condition match type
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_DATA_TYPE = 0x00106004,
         // Malformed query: Invalid condition data type
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY_AND_DATA_TYPE = 0x00106005,
         // Malformed query: Invalid key and data type combination
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEYS_PROTOCOL_PORT = 0x00106006,
         // Malformed query: Protocol condition present without a protocol
         // condition
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROFILE = 0x00106007,
         // Malformed query: Profile Key unavailable for this object type
         // queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_STATUS = 0x00106008,
         // Malformed query: Status Key unavailable for this object type
         // queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_FILTERID = 0x00106009,
         // Malformed query: FilterID Key unavailable for this object type
         // queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_APP_PATH = 0x00106010,
         // Malformed query: Application Key unavailable for this object
         // type queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROTOCOL = 0x00106011,
         // Malformed query: Protocol Key unavailable for this object type
         // queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_LOCAL_PORT = 0x00106012,
         // Malformed query: Local Port Key unavailable for this object type
         // queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_REMOTE_PORT = 0x00106013,
         // Malformed query: Remote Port Key unavailable for this object
         // type queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_SVC_NAME = 0x00106015,
         // Malformed query: Service Name Key unavailable for this object
         // type queried
  
     FW_RULE_STATUS_SEMANTIC_ERROR_REQUIRE_IN_CLEAR_OUT_ON_TRANSPORT = 0x00107000,
         // Authentication mode,"Require inbound and clear outbound" can
         // only be set when using IPsec tunneling. 
  
     FW_RULE_STATUS_SEMANTIC_ERROR_BYPASS_TUNNEL_IF_SECURE_ON_TRANSPORT = 0x00107001,
         // Bypass Tunnel If Secure may not be set on Transport-Mode rules.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00107002,
         // Authentication (No Encapsulation) may not be used on tunnel-mode
         // rules.
  
     FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_PSK = 0x00107003,
         // Authentication (No Encapsulation) may not be used on rules that
         // contain preshared keys.
  
     FW_RULE_STATUS_RUNTIME_ERROR = 0x00200000,
         // A runtime error occurred while trying to enforce the rule.
  
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_AUTH_NOT_FOUND = 0x00200001,
         // The phase 1 authentication set was not found.
  
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_AUTH_NOT_FOUND = 0x00200002,
         // The phase 2 authentication set was not found.
  
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_CRYPTO_NOT_FOUND = 0x00200003,
         // The quick mode cryptographic set was not found.
  
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_MCHN_SHKEY_MISMATCH = 0x00200004,
         // A conflict was detected between the phase 1 and phase 2
         // authentication sets. When preshared keys are used in phase 1,
         // there cannot be a phase 2 authentication set.
  
     FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_CRYPTO_NOT_FOUND = 0x00200005,
         // The main mode cryptographic set was not found.
  
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00200006,
         // Authentication (No Encapsulation) cannot be specified on a
         // tunnel-mode rule. 
  
     FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_PSK = 0x00200007,
         // Authentication (No Encapsulation) cannot be specified on a rule
         // that uses a preshared key. 
  
     FW_RULE_STATUS_RUNTIME_ERROR_KEY_MODULE_AUTH_MISMATCH = 0x00200008,
         // The key module in the rule is incompatible with the
         // authentication methods specified in the associated
         // authentication sets.
  
     FW_RULE_STATUS_ERROR  = FW_RULE_STATUS_PARSING_ERROR |FW_RULE_STATUS_SEMANTIC_ERROR   
     |FW_RULE_STATUS_RUNTIME_ERROR,
         // An error occurred.
  
     FW_RULE_STATUS_ALL = 0xFFFF0000
         // Enumerate all rules, regardless of status.
 } FW_RULE_STATUS;
  
  
 //rule status bitflags
 typedef enum _tag_FW_RULE_STATUS_CLASS
 {
     FW_RULE_STATUS_CLASS_OK                 = FW_RULE_STATUS_OK, // The rule was parsed successfully from the store
     FW_RULE_STATUS_CLASS_PARTIALLY_IGNORED  = FW_RULE_STATUS_PARTIALLY_IGNORED, // The rule has fields that the service can successfully ignore
     FW_RULE_STATUS_CLASS_IGNORED            = FW_RULE_STATUS_IGNORED, // The rule has a higher version that the service must ignore
     FW_RULE_STATUS_CLASS_PARSING_ERROR      = FW_RULE_STATUS_PARSING_ERROR, // The rule failed to be parsed correctly
     FW_RULE_STATUS_CLASS_SEMANTIC_ERROR     = FW_RULE_STATUS_SEMANTIC_ERROR, //There is a semantic error when considering the fields of the rule in conjunction
     FW_RULE_STATUS_CLASS_RUNTIME_ERROR      = FW_RULE_STATUS_RUNTIME_ERROR, // There is a runtime error when the object is considered in conjuntion with other Policy Objects.
  
     FW_RULE_STATUS_CLASS_ERROR              = FW_RULE_STATUS_ERROR, // An Error occurred
  
     FW_RULE_STATUS_CLASS_ALL                = FW_RULE_STATUS_ALL // All the status. (Used to enum ALL the rules, regardless the status.)
 } FW_RULE_STATUS_CLASS;
  
  
  
 typedef enum _tag_FW_OBJECT_CTRL_FLAG
 {                          
     FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA     = 0x0001, // Allow RPC to marshall the metadata pointer in the objects
 } FW_OBJECT_CTRL_FLAG;
  
  
 typedef enum _tag_FW_ENFORCEMENT_STATE
 {
     FW_ENFORCEMENT_STATE_INVALID,
     FW_ENFORCEMENT_STATE_FULL,
     FW_ENFORCEMENT_STATE_WF_OFF_IN_PROFILE,
     FW_ENFORCEMENT_STATE_CATEGORY_OFF,
     FW_ENFORCEMENT_STATE_DISABLED_OBJECT,
     FW_ENFORCEMENT_STATE_INACTIVE_PROFILE,
     FW_ENFORCEMENT_STATE_LOCAL_ADDRESS_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_ADDRESS_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_LOCAL_PORT_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_PORT_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_INTERFACE_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_APPLICATION_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_MACHINE_EMPTY,
     FW_ENFORCEMENT_STATE_REMOTE_USER_EMPTY,
     FW_ENFORCEMENT_STATE_LOCAL_GLOBAL_OPEN_PORTS_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_AUTHORIZED_APPLICATIONS_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_FIREWALL_RULES_DISALLOWED,
     FW_ENFORCEMENT_STATE_LOCAL_CONSEC_RULES_DISALLOWED,
     FW_ENFORCEMENT_STATE_MISMATCHED_PLATFORM,
     FW_ENFORCEMENT_STATE_OPTIMIZED_OUT,
     FW_ENFORCEMENT_STATE_LOCAL_USER_EMPTY,
     FW_ENFORCEMENT_STATE_TRANSPORT_MACHINE_SD_EMPTY,
     FW_ENFORCEMENT_STATE_TRANSPORT_USER_SD_EMPTY,
     FW_ENFORCEMENT_STATE_TUPLE_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_NETNAME_RESOLUTION_EMPTY,
     FW_ENFORCEMENT_STATE_MAX
 } FW_ENFORCEMENT_STATE;
  
  
 typedef struct _tag_FW_OBJECT_METADATA
 {
     UINT64 qwFilterContextID;
  
     [range(0, 100)]
     DWORD dwNumEntries;
     [size_is(dwNumEntries)]
     FW_ENFORCEMENT_STATE *pEnforcementStates;
 } FW_OBJECT_METADATA, *PFW_OBJECT_METADATA;
  
  
 typedef enum _tag_FW_OS_PLATFORM_OP
 {
     FW_OS_PLATFORM_OP_EQ,
     FW_OS_PLATFORM_OP_GTEQ,
     FW_OS_PLATFORM_OP_MAX,
     FW_OS_PLATFORM_OP_FIELD_SIZE = 5,
     FW_OS_PLATFORM_OP_FIELD_MASK = 0xF8
 } FW_OS_PLATFORM_OP;
  
  
 // Values for platform, major and minor versions correspond to values in the OSVERSIONINFOEX structure
 typedef struct _tag_FW_OS_PLATFORM
 {
     BYTE    bPlatform;
     BYTE    bMajorVersion;
     BYTE    bMinorVersion;
     BYTE    Reserved;
 }FW_OS_PLATFORM, *PFW_OS_PLATFORM;
  
 typedef struct _tag_FW_OS_PLATFORM_LIST
 {
     [range(0, 10000)]
     DWORD              dwNumEntries;
     [size_is(dwNumEntries)]
     PFW_OS_PLATFORM    pPlatforms;
 }FW_OS_PLATFORM_LIST, *PFW_OS_PLATFORM_LIST;
  
  
 typedef struct _tag_FW_NETWORK_NAMES
 {
     DWORD dwNumEntries;
     [string, unique, size_is(dwNumEntries,)]
     LPWSTR *wszNames;
 } FW_NETWORK_NAMES, *PFW_NETWORK_NAMES;
  
 typedef enum _tag_FW_RULE_ORIGIN_TYPE
 {
     FW_RULE_ORIGIN_INVALID,
     FW_RULE_ORIGIN_LOCAL,
     FW_RULE_ORIGIN_GP,
     FW_RULE_ORIGIN_DYNAMIC,
     FW_RULE_ORIGIN_AUTOGEN,
     FW_RULE_ORIGIN_HARDCODED,
     FW_RULE_ORIGIN_MAX
 }FW_RULE_ORIGIN_TYPE;
  
  
 typedef enum _tag_FW_ENUM_RULES_FLAGS
 {
     FW_ENUM_RULES_FLAG_NONE                 = 0x0000,
     FW_ENUM_RULES_FLAG_RESOLVE_NAME         = 0x0001, // Resolves rule name if in the format of '@file.dll,-<resID>'
     FW_ENUM_RULES_FLAG_RESOLVE_DESCRIPTION  = 0x0002, // Resolves rule descriptions if in the format of '@file.dll,-<resID>'
     FW_ENUM_RULES_FLAG_RESOLVE_APPLICATION  = 0x0004, // Resolves environment variables in the application string
     FW_ENUM_RULES_FLAG_RESOLVE_KEYWORD      = 0x0008, // Resolves Keywords in addresses and ports to the actual addresses and ports (dynamic store only)
     FW_ENUM_RULES_FLAG_RESOLVE_GPO_NAME     = 0x0010, // Resolves GPO name for the GP_RSOP rules 
     FW_ENUM_RULES_FLAG_EFFECTIVE            = 0x0020, // Enum Rules only if we attempted to push them to BFE (dynamic store only)
     FW_ENUM_RULES_FLAG_INCLUDE_METADATA     = 0x0040, // Inlude Object MetaData in the Enumerated Object.
     FW_ENUM_RULES_FLAG_MAX                  = 0x0080
 }FW_ENUM_RULES_FLAGS;
  
  
 //ordered by priority - highest on top
 typedef enum _tag_FW_RULE_ACTION
 {
     FW_RULE_ACTION_INVALID = 0,
     FW_RULE_ACTION_ALLOW_BYPASS,
     FW_RULE_ACTION_BLOCK,
     FW_RULE_ACTION_ALLOW,
     FW_RULE_ACTION_MAX
 } FW_RULE_ACTION;
  
 typedef enum _tag_FW_RULE_FLAGS
 {
     FW_RULE_FLAGS_NONE              = 0x0000,
     FW_RULE_FLAGS_ACTIVE            = 0x0001,
     FW_RULE_FLAGS_AUTHENTICATE      = 0x0002,
     FW_RULE_FLAGS_AUTHENTICATE_WITH_ENCRYPTION = 0x0004,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE = 0x0008,
     FW_RULE_FLAGS_LOOSE_SOURCE_MAPPED = 0x00010,
     FW_RULE_FLAGS_MAX_V2_1          = 0x0020,
     // This is the new "NoEncapsulation" flag in Windows 7 and Windows Server 2008 R2.
     FW_RULE_FLAGS_AUTH_WITH_NO_ENCAPSULATION = 0x0020,
     FW_RULE_FLAGS_MAX_V2_9          = 0x0040,
     // These are the new flags added for SSP in Windows 7 and Windows Server 2008 R2.
     FW_RULE_FLAGS_AUTH_WITH_ENC_NEGOTIATE = 0x0040,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE_DEFER_APP = 0x0080,
     FW_RULE_FLAGS_ROUTEABLE_ADDRS_TRAVERSE_DEFER_USER = 0x0100,    
     FW_RULE_FLAGS_AUTHENTICATE_BYPASS_OUTBOUND = 0x0200,
     FW_RULE_FLAGS_MAX_V2_10         = 0x0400,
     // This is the new flag in Windows 8 and Windows Server 2012 to allow profile crossings
     // for clusters.
     FW_RULE_FLAGS_ALLOW_PROFILE_CROSSING = 0x0400,
     // This is the new flag in Windows 8 and Windows Server 2012 to allow LOM on flows.
     FW_RULE_FLAGS_LOCAL_ONLY_MAPPED = 0x0800,
     FW_RULE_FLAGS_MAX_V2_20         = 0x1000,
     FW_RULE_FLAGS_LUA_CONDITIONAL_ACE = 0x1000,
     FW_RULE_FLAGS_BIND_TO_INTERFACE = 0x2000,
     FW_RULE_FLAGS_MAX               = 0x4000,
 }FW_RULE_FLAGS;
  
 typedef enum _tag_FW_RULE_FLAGS2
 {
     FW_RULE_FLAGS2_NONE                = 0x0000,
     FW_RULE_FLAGS2_SYSTEMOS_ONLY       = 0x0001,
     FW_RULE_FLAGS2_GAMEOS_ONLY         = 0x0002,
     FW_RULE_FLAGS2_DEVMODE             = 0x0004,
     FW_RULE_FLAGS_MAX_V2_26            = 0x0008,
     FW_RULE_FLAGS2_NOT_USED_VALUE_8    = 0x0008,
     FW_RULE_FLAGS2_NOT_USED_VALUE_16   = 0x0010,
     FW_RULE_FLAGS2_NOT_USED_VALUE_32   = 0x0020,
     FW_RULE_FLAGS2_NOT_USED_VALUE_64   = 0x0040,
     FW_RULE_FLAGS2_CALLOUT_AND_AUDIT   = 0x0080,
     FW_RULE_FLAGS2_NOT_USED_VALUE_256  = 0x0100,
     FW_RULE_FLAGS2_NOT_USED_VALUE_512  = 0x0200, 
     FW_RULE_FLAGS2_NOT_USED_VALUE_1024 = 0x0400,
     FW_RULE_FLAGS2_MAX                 = 0x0800
 }FW_RULE_FLAGS2;
    
 typedef struct _tag_FW_RULE2_0
 {
     struct _tag_FW_RULE2_0 *pNext;                
     WORD         wSchemaVersion;
     [string, range(1,10001), ref]
     WCHAR*       wszRuleId;
     [string, range(1,10001)]
     WCHAR*       wszName;
     [string, range(1,10001)]
     WCHAR*       wszDescription;
     DWORD        dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION Direction;
     [range(0,256)]
     WORD         wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct
         {
             FW_PORTS LocalPorts;
             FW_PORTS RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST  V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST  V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     WCHAR*              wszLocalApplication;
     [string, range(1,10001)]
     WCHAR*              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     WCHAR*              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     WCHAR*              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL                
  
     [string, range(1,10001)]
     WCHAR*           wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS   Status;  //Parsing error if any, filled on return. On input, set this
                               // to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules.
                                     // Ignored on input
     [string, range(1,10001)]
     WCHAR*           wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD            Reserved;
  
 } FW_RULE2_0, *PFW_RULE2_0;
  
  
 typedef struct _tag_FW_RULE2_10
 {
     struct _tag_FW_RULE2_10 *pNext;                
     WORD          wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR        wszRuleId;
     [string, range(1,10001)]
     LPWSTR        wszName;
     [string, range(1,10001)]
     LPWSTR        wszDescription;
     DWORD         dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION  Direction;
     [range(0,256)]
     WORD          wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct {
         
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST    V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST    V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL                
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return. 
                                     // On input, set this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules.
                                     // Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
 } FW_RULE2_10, *PFW_RULE2_10;
  
  
  
 typedef struct _tag_FW_RULE2_20
 {
     struct _tag_FW_RULE2_20 *pNext;                
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct 
         {  
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL                
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return.
                                     // On input, set     this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules.
                                     // Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;     //Authorized local users SDDL    
  
     [string, range(1,10001)]
     WCHAR *             wszPackageId;     // Application Container Package Id Sid
  
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;     // User Owner of the Rule
  
     // Trust Tuple Keywords
     DWORD               dwTrustTupleKeywords;
  
 } FW_RULE2_20, *PFW_RULE2_20;
  
  
 typedef struct _tag_FW_RULE2_24
 {
     struct _tag_FW_RULE2_24 *pNext;                
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct
         {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         // ICMP types-codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL                
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return. On input, set this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules.
                                     //Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
     [string, range(1,10001)]
     WCHAR*             wszLocalUserAuthorizationList;     //Authorized local users SDDL    
  
     [string, range(1,10001)]
     WCHAR *            wszPackageId;     // Application Container Package Id Sid
  
     [string, range(1,10001)]
     WCHAR *            wszLocalUserOwner;     // User Owner of the Rule
  
     // Trust Tuple Keywords
     DWORD              dwTrustTupleKeywords;
  
     FW_NETWORK_NAMES   OnNetworkNames;
     [string, range(1,10001)]
     // security realm Id
     WCHAR*             wszSecurityRealmId;    // Security Realm Id
 } FW_RULE2_24, *PFW_RULE2_24;
  
  
 typedef struct _tag_FW_RULE2_25
 {
     struct _tag_FW_RULE2_25 *pNext;                
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct
         {
             FW_PORTS             LocalPorts;
             FW_PORTS             RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST   V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST   V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL                
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return.
                                     //On input, set this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules.
                                     //Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;     //Authorized local users SDDL    
  
     [string, range(1,10001)]
     WCHAR *             wszPackageId;     // Application Container Package Id Sid
  
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;     // User Owner of the Rule
  
     // Trust Tuple Keywords
     DWORD               dwTrustTupleKeywords;
  
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
     // security realm Id
     WCHAR*              wszSecurityRealmId;    // Security Realm Id
  
     WORD                wFlags2;      // Bit flags from FW_RULE_FLAGS2
  
 } FW_RULE2_25, *PFW_RULE2_25;
  
  
 typedef struct _tag_FW_RULE2_26
 {
     struct _tag_FW_RULE2_26 *pNext;                
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct
         {
     FW_PORTS        LocalPorts;
         FW_PORTS       RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST      V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST      V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList; //Authorized remote machines SDDL [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;    //Authorized remote users SDDL  
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return. On input, set this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules. Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;     //Authorized local users SDDL    
  
     [string, range(1,10001)]
     WCHAR *             wszPackageId;     // Application Container Package Id Sid
  
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;     // User Owner of the Rule
  
     // Trust Tuple Keywords
     DWORD               dwTrustTupleKeywords;
  
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
     // security realm Id
     WCHAR*              wszSecurityRealmId;    // Security Realm Id
  
     WORD                wFlags2;      // Bit flags from FW_RULE_FLAGS2
  
     FW_NETWORK_NAMES    RemoteOutServerNames;
  
 } FW_RULE2_26, *PFW_RULE2_26;
  
 typedef struct _tag_FW_RULE2_27 
 {
    struct _tag_FW_RULE2_27 *pNext;  
    unsigned short                  wSchemaVersion; 
    [string, range(1, 512), ref]    wchar_t* wszRuleId; 
    [string, range(1, 10001)]       wchar_t* wszName;    
    [string, range(1, 10001)]       wchar_t* wszDescription;  unsigned long dwProfiles; 
    [range(FW_DIR_INVALID, FW_DIR_OUT)]  
    FW_DIRECTION Direction; 
    [range(0, 256)] unsigned short  wIpProtocol;  
    [switch_type(unsigned short), switch_is(wIpProtocol)]
      union {  [case(6,17)] struct { 
        FW_PORTS                    LocalPorts; 
        FW_PORTS                    RemotePorts;    
        }; 
        [case(1)]  
        FW_ICMP_TYPE_CODE_LIST      V4TypeCodeList; 
        [case(58)]  
        FW_ICMP_TYPE_CODE_LIST      V6TypeCodeList; 
        [default]; 
      }; 
    FW_ADDRESSES                    LocalAddresses; 
    FW_ADDRESSES                    RemoteAddresses;  
    FW_INTERFACE_LUIDS              LocalInterfaceIds;  
      unsigned long                 dwLocalInterfaceTypes; 
 [string, range(1, 10001)] wchar_t* wszLocalApplication;  
 [string, range(1, 10001)] wchar_t* wszLocalService; 
      [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]  
    FW_RULE_ACTION                  Action;    
      unsigned short                wFlags; 
 [string, range(1, 10001)] wchar_t* wszRemoteMachineAuthorizationList; 
 [string, range(1, 10001)] wchar_t* wszRemoteUserAuthorizationList; 
 [string, range(1, 10001)] wchar_t* wszEmbeddedContext; 
    FW_OS_PLATFORM_LIST             PlatformValidityList;  
    FW_RULE_STATUS                  Status; 
    [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]  
    FW_RULE_ORIGIN_TYPE Origin; 
 [string, range(1, 10001)] wchar_t* wszGPOName;  
 unsigned long Reserved; 
      [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]  
    PFW_OBJECT_METADATA             pMetaData; 
   [string, range(1, 10001)] WCHAR* wszLocalUserAuthorizationList; 
   [string, range(1, 10001)] WCHAR* wszPackageId;  
  [string, range(1, 10001)] WCHAR*  wszLocalUserOwner; 
      unsigned long                 dwTrustTupleKeywords; 
    FW_NETWORK_NAMES                OnNetworkNames; 
      [string, range(1, 10001)] WCHAR* wszSecurityRealmId; 
      unsigned short                wFlags2;   
    FW_NETWORK_NAMES                RemoteOutServerNames;  
    [string, range(1,10001)] WCHAR* wszFqbn;  
    unsigned long                   compartmentId; 
 }FW_RULE2_27, 
 *PFW_RULE2_27;
  
  
 typedef struct _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST 
 { 
 DWORD dwNumIds;  
 [size_is(dwNumIds)] UINT32* ids;
 }
 FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST,
 *PFW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST;
  
  
 typedef struct _tag_FW_RULE
 {
     struct _tag_FW_RULE *pNext;                
     WORD            wSchemaVersion;
     [string, range(1,512), ref]
     LPWSTR          wszRuleId;
     [string, range(1,10001)]
     LPWSTR          wszName;
     [string, range(1,10001)]
     LPWSTR          wszDescription;
     DWORD           dwProfiles;
     [range(FW_DIR_INVALID, FW_DIR_OUT)]
     FW_DIRECTION    Direction;
     [range(0,256)]
     WORD            wIpProtocol; //0-255 or FW_IP_PROTOCOL_ANY
     [switch_type(WORD), switch_is(wIpProtocol)]
     union 
     {
         // Ports specified if wIpProtocol = 6(TCP) or 17(UDP)
         [case(6,17)]
         struct
         {
             FW_PORTS            LocalPorts;
             FW_PORTS            RemotePorts;
         };
         // ICMP types/codes specified if wIpProtocol = 1(ICMPv4) or 58(ICMPv6)
         [case(1)]
         FW_ICMP_TYPE_CODE_LIST  V4TypeCodeList;
         [case(58)]
         FW_ICMP_TYPE_CODE_LIST  V6TypeCodeList;
         [default] 
         ;
     };
  
     FW_ADDRESSES        LocalAddresses;
     FW_ADDRESSES        RemoteAddresses;
     FW_INTERFACE_LUIDS  LocalInterfaceIds;
     DWORD               dwLocalInterfaceTypes;    // Bit flags from FW_INTERFACE_TYPE
     [string, range(1,10001)]
     LPWSTR              wszLocalApplication;
     [string, range(1,10001)]
     LPWSTR              wszLocalService;
     [range(FW_RULE_ACTION_INVALID, FW_RULE_ACTION_MAX)]
     FW_RULE_ACTION      Action;
     WORD                wFlags;      // Bit flags from FW_RULE_FLAGS     
  
     [string, range(1,10001)]
     LPWSTR              wszRemoteMachineAuthorizationList;  //Authorized remote machines SDDL
     [string, range(1,10001)]
     LPWSTR              wszRemoteUserAuthorizationList;     //Authorized remote users SDDL   
  
     [string, range(1,10001)]
     LPWSTR              wszEmbeddedContext;
     FW_OS_PLATFORM_LIST PlatformValidityList;
     
     FW_RULE_STATUS      Status;     //Parsing error if any, filled on return. On input, set this to FW_RULE_STATUS_OK
     [range(FW_RULE_ORIGIN_INVALID, FW_RULE_ORIGIN_MAX)]
     FW_RULE_ORIGIN_TYPE Origin;     //Rule origin, filled on enumerated rules. Ignored on input
     [string, range(1,10001)]
     LPWSTR              wszGPOName; //Name of originating GPO, if rule origin is GP.
     DWORD               Reserved; 
  
  
 //    [switch_type(WORD), switch_is(wBinaryVersion)]
 //    union
 //    {
 //    [case(wBinaryVersion >= 0x0210)]
 //    struct
 //    {
     [size_is((Reserved & FW_OBJECT_CTRL_FLAG_INCLUDE_METADATA) ? 1 : 0)]
     PFW_OBJECT_METADATA pMetaData;
  
 //    };
 //    }; // End union wBinaryVersion
  
     [string, range(1,10001)]
     WCHAR*              wszLocalUserAuthorizationList;     //Authorized local users SDDL    
  
     [string, range(1,10001)]
     WCHAR *             wszPackageId;     // Application Container Package Id Sid
  
     [string, range(1,10001)]
     WCHAR *             wszLocalUserOwner;     // User Owner of the Rule
  
     // Trust Tuple Keywords
     DWORD               dwTrustTupleKeywords;
  
     FW_NETWORK_NAMES    OnNetworkNames;
     [string, range(1,10001)]
    // Security realm Id    
     WCHAR* wszSecurityRealmId;   // Security Realm Id    
        
     WORD   wFlags2;      // Bit flags from FW_RULE_FLAGS2    
    FW_NETWORK_NAMES    RemoteOutServerNames;
    [string, range(1,10001)]
    WCHAR* wszFqbn; 
    DWORD compartmentId;
     GUID  providerContextKey;
     FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST  RemoteDynamicKeywordAddresses;
 
}  FW_RULE, *PFW_RULE;